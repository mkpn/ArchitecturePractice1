# リファクタリング手順の記録
## MessageInputValidatorを作成
MessageSenderが複雑なバリデーションロジックを抱え込んでいる問題がありました。
バリデーションという十分に大きな関心ごとは、MessageSender本来の目的である「メッセージ送信」とは別の関心であり、別の型として扱うべきだという可能性を示唆しています。
ここでは SOLID 原則の S、単一責任原則をヒントにリファクタリングすることにしました。
単一責任原則(Single Responsibility Principle)
- クラス(型)を変更する理由はふたつ以上存在してはならない

また、凝集度について確認した時、
手続き的凝集(Procedural Cohesion)
- ある種の処理を行うときに動作する部分を集めたモジュール(たとえば、ファイルの パーミッションをチェックするルーチンとファイルをオープンするルーチンなど)
とあり、MessageSender は典型的な手続き的凝集の罠を踏んでしまったのだと分かります

「変更の理由」という観点はクリアしているでしょうか?
メッセージ種別が増えたりバリデーション条件が変わることは十分にありえます。そのようなときに困りそうなので、今は見通しが悪いコードをリファクタしたいのです。そう感じることも立派な変更の理由です。
やはりこの臭いの元は、単一責任原則に反していることのようです。
注：単一責任原則できているかの判断基準は、*変更の理由が一つかどうか*

MessageInputValidator という型を作って、そこにバリデーションのロジックを閉じ込めることにしました。

## ImageMessageInputValidatorを作成
MessageInputValidatorのisTextValid の内部処理では、TextMessage の場合と ImageMessage の場合を switch で分けています。
しかし本来このふたつは関連のない処理のはずです。Messageの種別ごとに必要なバリデーションロジックが違うなら、そもそもまとめて switch する必要がないのです。
「変更の理由」の観点も確認してみましょう。「TextMessage のバリデーション」と「ImageMessage のバリデーション」の変更の理由は、確かに異なります。
つまりこれらは別のモジュールとして分離すべきものだといえます。

メモ：
これは、作成したMessageInputValidatorは「TextMessageをValidとみなすルールの変更変更」と「ImageMessageをValidとみなすルールの仕様変更」によって変更される。
つまり*変更する理由が複数存在するためSRPの原則を守れていない*のだと解釈しています。

凝集度について確認すると
論理的凝集(Logical Cohesion)
- 論理的に似たようなことをするものを集めたモジュール(たとえば、全ての入出力ルーチンを集めたモジュールなど)
とあり「メッセージのバリデーション」という目的で雑にまとめられたValidatorクラスがこの罠に陥っているのだと考えられます

サンプルに従ってImageMessageInputValidatorを作成しました。
分岐がなくなったので本来の関心だけを小さく切り取れて、見通しが良くなりました。
ImageMessage の入力値に関連するプロパティは image と text だと一目瞭然になりました。
テスト対象は小さければ小さいほどフットワークが軽くなります。小さく型を分けることはテストの書きやすさ、ひいては「早く開発する」ことにつながります。

## 本当に「ImageMessageInputValidator」でいいのか考える
> 作った型を ImageMessageInputValidator と名付けましたが、この型名には違和感を覚えます。
> まるで ImageMessageInput という概念があるように見えます。...いいえ、実際あるのでしょう。
> そして ImageMessageInput は、対応する Validator と同じ責務=変更の理由 をもつ存在と言ってよいでしょう。

この辺、言語化が難しいけど、言ってることはなんとなくわかる・・・

> 型の責務(変更の理由)はふたつ以上存在してはならない」という原則は、「変更の理由が同じなら、同じ型にしてよい」ということも示します。

これは「へぇ〜」て思った。そういう考え方もあるんだなぁみたいな。ちゃんと自分の引き出しに増やしたいな。

> バリデーションは ImageMessageInput 自身の知識として統合してもよさそうです。
> データ構造の変更は不要でしょう。未入力が nil になることを考慮した image: UIImage?と text: String?を持つという構造は、
> ImageMessageInputValidator でも ImageMessageInput でも変わらないからです。
> 型名をリネームし、let で表現していたプロパティを再代入可能な var にするだけで、自然に責務を再定義できました。

自身が整合性をチェックできる構造はよく見かけるし、感覚的にもImageMessageInputという命名で表現されてる変更後のクラスの方がスッキリしていると思う。
MessageInputという概念があるとして、ちゃんと表現するならMessageInputはクラスで定義されているべきだと思うし、
そうなった時、わざわざValidationクラスを別に設けるのは、少なくとも本書のケースにおいては冗長に思う。
ということで、ImageMessageInputにリネームして、varに変更。varにする理由は正直言語化できてないけどまぁ、なんとなくわかるかなって感じ。。。