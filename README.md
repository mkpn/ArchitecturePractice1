# 単一責任原則(Single Responsibility Principle)を適用する
問題のひとつは、この型が複雑なバリデーションロジックを抱え込んでいる点です。
isValid には引数がありません。どういう条件で isValid が変化するのでしょうか。
依存しているプロパティは暗黙的で、コードを丹念に追わないと分かりません。
しっかり読めば、 依存しているのは messageType と各種の入力値だと分かりますが、TextMessage の場合と ImageMessage の場合で条件は変わります。
新しいメッセージ種別や新しい条件が増えたら、ますますコードは複雑になることでしょう。

コードから次のような臭いが漂ってきました。
- 硬さ:変更しにくいシステム。1つの変更によってシステムの他の部分に影響が及び、 多くの変更を余儀なくさせるようなソフトウェア
- もろさ:1つの変更によって、その変更とは概念的に関連のない箇所まで壊れてしまうようなソフトウェア
- 扱いにくさ:正しいことをするよりも、誤ったことをするほうが容易なソフトウェア
- 不必要な繰り返し:同じような構造を繰り返し含み、抽象化してまとめらられる部分がまとまっていないソフトウェア

ここでは SOLID 原則の S、単一責任原則がヒント
になりそうです。
単一責任原則(Single Responsibility Principle)
- クラス(型)を変更する理由はふたつ以上存在してはならない

単一責任原則について勘違いしやすいのが、*判断の基準になるのが 変更の理由であるという点です。*
バリデーションは十分に大きな関心事です。しかしそれは MessageSender 本来の目的である「メッセージ送信」とは別の関心であり、別の型として扱うべきだという可能性を示唆しています。
凝集度について確認してみると、今回の例によく似た説明がありました*2 。
手続き的凝集(Procedural Cohesion)
- ある種の処理を行うときに動作する部分を集めたモジュール(たとえば、ファイルの パーミッションをチェックするルーチンとファイルをオープンするルーチンなど) 
ここからも、MessageSender は典型的な手続き的凝集の罠を踏んでしまったのだと分かります
 「変更の理由」という観点はクリアしているでしょうか?
 メッセージ種別が増えたりバリデーション条件が変わることは十分にありえます。そのようなときに困りそうなので、今は見通しが悪いコードをリファクタしたいのです。そう感じることも立派な変更の理由です。
 やはりこの臭いの元は、単一責任原則に反していることのようです。
 それでは MessageInputValidator という型を作って、そこにバリデーションのロジック を閉じ込めることにしましょうか。

＞ MessageInputValidatorを作成